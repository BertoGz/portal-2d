<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portal 2d (demo)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #eee;
            user-select: none;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            background-color: #222;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            outline: none;
        }

        /* UI Overlay (Pause Menu) */
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            display: none; /* Hidden by default, shown when paused */
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(5px);
        }

        #ui.paused {
            display: flex;
            pointer-events: auto;
        }

        /* Main Menu Overlay */
        #main-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #222;
            background: radial-gradient(circle, #333 0%, #111 100%);
        }

        #main-menu.hidden {
            display: none;
        }

        .menu-box {
            background: rgba(51, 51, 51, 0.9);
            padding: 50px;
            border-radius: 20px;
            border: 1px solid #555;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8);
            text-align: center;
            min-width: 450px;
            animation: float 6s ease-in-out infinite;
        }

        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }

        .pause-menu {
            background: #333;
            padding: 40px;
            border-radius: 16px;
            border: 1px solid #555;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            text-align: center;
            min-width: 400px;
        }

        h1 { 
            margin: 0 0 10px 0; 
            font-size: 42px; 
            color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5); 
            letter-spacing: 2px;
            text-transform: uppercase;
            font-weight: 800;
        }

        .subtitle {
            color: #aaa;
            font-size: 18px;
            margin-bottom: 30px;
            letter-spacing: 1px;
        }
        
        .controls {
            margin: 20px 0;
            padding: 20px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            text-align: left;
        }

        p { margin: 8px 0; font-size: 15px; opacity: 0.9; color: #ccc; }
        
        .key {
            display: inline-block;
            background: #eee;
            color: #333;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 12px;
            margin: 0 2px;
            box-shadow: 0 2px 0 #aaa;
        }

        button {
            background: #00A2FF;
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 8px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s, box-shadow 0.2s;
            margin-top: 20px;
            box-shadow: 0 4px 0 #0077CC;
        }

        button:hover {
            background: #33b5ff;
            transform: translateY(-2px);
            box-shadow: 0 6px 0 #0077CC;
        }

        button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #0077CC;
        }

        .start-btn {
            background: #FF9900;
            box-shadow: 0 4px 0 #cc7a00;
        }
        .start-btn:hover {
            background: #ffad33;
            box-shadow: 0 6px 0 #cc7a00;
        }
        .start-btn:active {
            box-shadow: 0 2px 0 #cc7a00;
        }
    </style>
</head>
<body>

<div id="game-container">
    <!-- Main Menu -->
    <div id="main-menu">
        <div class="menu-box">
            <h1>Portal 2d</h1>
            <div class="subtitle">(demo)</div>
            <div class="controls">
                <p><span class="key">W</span> <span class="key">A</span> <span class="key">S</span> <span class="key">D</span> to Move & Jump</p>
                <p><span class="key">Q</span> Shoot Blue Portal</p>
                <p><span class="key">E</span> Shoot Orange Portal</p>
                <p><span class="key">Space</span> Hold to View Portals</p>
            </div>
            <button id="startBtn" class="start-btn">START GAME</button>
        </div>
    </div>

    <!-- Pause UI -->
    <div id="ui">
        <div class="pause-menu">
            <h1>PAUSED</h1>
            <div class="controls">
                <p><span class="key">W</span> <span class="key">A</span> <span class="key">S</span> <span class="key">D</span> to Move & Jump</p>
                <p><span class="key">Q</span> Shoot Blue Portal</p>
                <p><span class="key">E</span> Shoot Orange Portal</p>
                <p><span class="key">Space</span> Hold to View Portals</p>
                <p><span class="key">ESC</span> to Resume</p>
            </div>
            <div style="display: flex; gap: 15px; justify-content: center; margin-top: 20px;">
                <button id="resumeBtn">RESUME</button>
                <button id="resetBtn">RESET</button>
            </div>
        </div>
    </div>
    <canvas id="gameCanvas" tabindex="0"></canvas>
</div>

<script>
/**
 * AUDIO SYSTEM (Web Audio API)
 */
class SoundManager {
    constructor() {
        this.ctx = null;
        this.ambienceNode = null;
        this.gainNode = null;
        this.initialized = false;
    }

    init() {
        if (this.initialized) return;
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
        this.initialized = true;
        this.startAmbience();
    }

    startAmbience() {
        const playDroneInstance = () => {
            if (!this.initialized) return;

            // Configuration
            const playDuration = 15 + Math.random() * 10; // Random duration between 15s and 25s
            const silenceDuration = 30; // Silence for 30 seconds
            const now = this.ctx.currentTime;

            // Randomize Tone Parameters
            // Frequencies: Low A, Low C, Low D, Low E, Low G (Cinematic minor pentatonic)
            const baseFreqs = [55.00, 65.41, 73.42, 82.41, 48.00]; 
            const baseFreq = baseFreqs[Math.floor(Math.random() * baseFreqs.length)];
            const detuneAmount = Math.random() * 15 + 5; // Random detune for texture thickness
            const filterFreq = 150 + Math.random() * 200; // Random brightness

            // Master gain for this drone instance (handles fade in/out)
            const instanceGain = this.ctx.createGain();
            instanceGain.connect(this.ctx.destination);

            // Envelope: Slow Fade In (4s) -> Sustain -> Slow Fade Out (5s)
            const fadeIn = 4;
            const fadeOut = 5;
            
            instanceGain.gain.setValueAtTime(0, now);
            instanceGain.gain.linearRampToValueAtTime(0.15, now + fadeIn); // Fade in to 15% volume
            instanceGain.gain.setValueAtTime(0.15, now + playDuration - fadeOut);
            instanceGain.gain.linearRampToValueAtTime(0, now + playDuration); // Fade out to 0

            // Oscillator 1: Deep Foundation (Sine or Triangle)
            const osc1 = this.ctx.createOscillator();
            osc1.type = Math.random() > 0.5 ? 'sine' : 'triangle';
            osc1.frequency.value = baseFreq; 
            osc1.connect(instanceGain);
            osc1.start(now);
            osc1.stop(now + playDuration);

            // Oscillator 2: Detuned Layer (Creates "beating" texture)
            const osc2 = this.ctx.createOscillator();
            osc2.type = 'sine';
            osc2.frequency.value = baseFreq;
            osc2.detune.value = detuneAmount; 
            osc2.connect(instanceGain);
            osc2.start(now);
            osc2.stop(now + playDuration);

            // Oscillator 3: Harmonic Texture (Octave up, filtered)
            const osc3 = this.ctx.createOscillator();
            osc3.type = 'sawtooth';
            osc3.frequency.value = baseFreq * 2; // Octave up
            
            // Lowpass filter to tame the sawtooth
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = filterFreq; 
            
            // LFO to modulate the filter (slow breathing movement)
            const lfo = this.ctx.createOscillator();
            lfo.type = 'sine';
            lfo.frequency.value = 0.1 + Math.random() * 0.1; // Very slow cycle
            const lfoGain = this.ctx.createGain();
            lfoGain.gain.value = 50; // Modulate filter freq by +/- 50Hz

            lfo.connect(lfoGain);
            lfoGain.connect(filter.frequency);
            lfo.start(now);
            lfo.stop(now + playDuration);

            osc3.connect(filter);
            filter.connect(instanceGain);
            osc3.start(now);
            osc3.stop(now + playDuration);

            // Schedule the next drone after Play Time + Silence Time
            // The timeout is in milliseconds
            setTimeout(playDroneInstance, (playDuration + silenceDuration) * 1000);
        };

        // Start the first loop immediately
        playDroneInstance();
    }

    playShoot(type) {
        if (!this.initialized) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();

        osc.type = 'triangle';
        
        // Pitch sweep (High to low zap)
        const now = this.ctx.currentTime;
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);

        // Volume envelope
        gain.gain.setValueAtTime(0.75, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);

        osc.connect(gain);
        gain.connect(this.ctx.destination);

        osc.start(now);
        osc.stop(now + 0.15);
    }

    playLand() {
        if (!this.initialized) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();

        osc.type = 'sine';
        
        // Lower thud/activation sound
        const now = this.ctx.currentTime;
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.2);

        gain.gain.setValueAtTime(0.75, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);

        osc.connect(gain);
        gain.connect(this.ctx.destination);

        osc.start(now);
        osc.stop(now + 0.2);
    }
}

const soundManager = new SoundManager();

/**
 * GAME CONFIGURATION & CONSTANTS
 */
const CONFIG = {
    GRAVITY: 0.2,         
    MOVE_SPEED: 3,         
    MAX_SPEED: 25,         
    HIGH_SPEED_GROUND_RETENTION: 0.98,  
    LOW_SPEED_GROUND_RETENTION: 0.70,   
    MIN_AIR_ACCEL: 0.05,        
    MAX_AIR_ACCEL: 0.2,         
    JUMP_FORCE: 8,
    SUBSTEPS: 16, 
    PORTAL_WIDTH: 60,
    PLAYER_SIZE: 24,
    PORTAL_ANCHOR_DISTANCE: 20, 
    ZOOM: 1.5,             
    CAM_LERP: 0.1,         
    CAM_LOOKAHEAD: 0.3,
    PORTAL_REDIRECT: 1.0,  
    PORTAL_SUCTION: 0,   
    PORTAL_SUCTION_SPEED_SCALE: 0.0,  
    PORTAL_SUCTION_PREDICT_TIME: 1.0,  
    MAX_CONTROL_LOCK_TIME: 0.5, 
    CONTROL_LOCK_SPEED_THRESHOLD: 4 
};

// World Dimensions
const WORLD_W = 1920; 
const WORLD_H = 1080;

/**
 * UTILITIES & MATH
 */
class Vec2 {
    constructor(x, y) { this.x = x; this.y = y; }
    add(v) { return new Vec2(this.x + v.x, this.y + v.y); }
    sub(v) { return new Vec2(this.x - v.x, this.y - v.y); }
    mult(s) { return new Vec2(this.x * s, this.y * s); }
    mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    normalize() {
        let m = this.mag();
        return m === 0 ? new Vec2(0, 0) : new Vec2(this.x / m, this.y / m);
    }
    rotate(angle) {
        return new Vec2(
            this.x * Math.cos(angle) - this.y * Math.sin(angle),
            this.x * Math.sin(angle) + this.y * Math.cos(angle)
        );
    }
    dot(v) { return this.x * v.x + this.y * v.y; }
}

function rectIntersect(r1, r2) {
    return !(r2.x > r1.x + r1.w || 
             r2.x + r2.w < r1.x || 
             r2.y > r1.y + r1.h || 
             r2.y + r2.h < r1.y);
}

function castRay(start, dir, walls) {
    let closest = null;
    let minDist = Infinity;
    let hitNormal = null;
    let end = start.add(dir.mult(3000)); 

    for (let wall of walls) {
        const lines = [
            { p1: new Vec2(wall.x, wall.y), p2: new Vec2(wall.x + wall.w, wall.y), n: new Vec2(0, -1) },
            { p1: new Vec2(wall.x, wall.y + wall.h), p2: new Vec2(wall.x + wall.w, wall.y + wall.h), n: new Vec2(0, 1) },
            { p1: new Vec2(wall.x, wall.y), p2: new Vec2(wall.x, wall.y + wall.h), n: new Vec2(-1, 0) },
            { p1: new Vec2(wall.x + wall.w, wall.y), p2: new Vec2(wall.x + wall.w, wall.y + wall.h), n: new Vec2(1, 0) }
        ];

        for (let line of lines) {
            const x1 = line.p1.x, y1 = line.p1.y;
            const x2 = line.p2.x, y2 = line.p2.y;
            const x3 = start.x, y3 = start.y;
            const x4 = end.x, y4 = end.y;

            const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (den === 0) continue;

            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;
            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;

            if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
                const hitX = x1 + t * (x2 - x1);
                const hitY = y1 + t * (y2 - y1);
                const dist = Math.sqrt((hitX - start.x) ** 2 + (hitY - start.y) ** 2);

                if (dist < minDist) {
                    minDist = dist;
                    closest = new Vec2(hitX, hitY);
                    hitNormal = line.n;
                }
            }
        }
    }
    return closest ? { pos: closest, normal: hitNormal, dist: minDist } : null;
}

/**
 * GAME CLASSES
 */

class Camera {
    constructor(x, y) {
        this.pos = new Vec2(x, y);
        this.lerpedPlayerPos = new Vec2(x, y); 
        const scaleFactor = canvas.height / WORLD_H;
        this.zoom = CONFIG.ZOOM * scaleFactor;
    }

    follow(playerPos, screenMouse, canvas, ghostData, portals, isSpaceHeld) {
        const playerLerp = 0.15; 
        this.lerpedPlayerPos.x += (playerPos.x - this.lerpedPlayerPos.x) * playerLerp;
        this.lerpedPlayerPos.y += (playerPos.y - this.lerpedPlayerPos.y) * playerLerp;
        
        let targetX, targetY;
        
        const scaleFactor = canvas.height / WORLD_H;
        let targetZoom = CONFIG.ZOOM * scaleFactor;

        if (isSpaceHeld && portals && portals[0].active && portals[1].active) {
            const p1 = portals[0].pos;
            const p2 = portals[1].pos;

            targetX = (p1.x + p2.x) / 2;
            targetY = (p1.y + p2.y) / 2;

            const portalWidth = CONFIG.PORTAL_WIDTH;
            const margin = 50; 
            const minBounds = 200;
            const boundsW = Math.max(minBounds, Math.abs(p1.x - p2.x) + portalWidth + margin * 2);
            const boundsH = Math.max(minBounds, Math.abs(p1.y - p2.y) + portalWidth + margin * 2);

            const zoomX = canvas.width / boundsW;
            const zoomY = canvas.height / boundsH;

            const maxZ = CONFIG.ZOOM * scaleFactor;
            const minZ = 0.5 * scaleFactor;
            targetZoom = Math.max(minZ, Math.min(maxZ, Math.min(zoomX, zoomY)));

        } else {
            let centerX = canvas.width / 2;
            let centerY = canvas.height / 2;
            
            let offX = (screenMouse.x - centerX) / this.zoom;
            let offY = (screenMouse.y - centerY) / this.zoom;

            const aspect = canvas.width / canvas.height;
            offY *= aspect * 2.2;

            let mouseWorldX = this.pos.x + offX;
            let mouseWorldY = this.pos.y + offY;

            const look = CONFIG.CAM_LOOKAHEAD;
            const wPlayer = 1.0 - look;
            const wMouse = look;
            
            let wGhost = 0;
            let ghostX = 0;
            let ghostY = 0;

            const totalWeight = wPlayer + wMouse + wGhost;

            targetX = (this.lerpedPlayerPos.x * wPlayer + mouseWorldX * wMouse + ghostX * wGhost) / totalWeight;
            targetY = (this.lerpedPlayerPos.y * wPlayer + mouseWorldY * wMouse + ghostY * wGhost) / totalWeight;
        }

        this.pos.x += (targetX - this.pos.x) * CONFIG.CAM_LERP;
        this.pos.y += (targetY - this.pos.y) * CONFIG.CAM_LERP;
        this.zoom += (targetZoom - this.zoom) * 0.05;

        let viewH_W = (canvas.width / this.zoom) / 2;
        let viewH_H = (canvas.height / this.zoom) / 2;
        
        this.pos.x = Math.max(viewH_W, Math.min(WORLD_W - viewH_W, this.pos.x));
        this.pos.y = Math.max(viewH_H, Math.min(WORLD_H - viewH_H, this.pos.y));
    }
    
    apply(ctx, canvas) {
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.scale(this.zoom, this.zoom);
        ctx.translate(-this.pos.x, -this.pos.y);
    }

    screenToWorld(screenPos, canvas) {
        let centerX = canvas.width / 2;
        let centerY = canvas.height / 2;
        return new Vec2(
            (screenPos.x - centerX) / this.zoom + this.pos.x,
            (screenPos.y - centerY) / this.zoom + this.pos.y
        );
    }
}

class Portal {
    constructor(id, color) {
        this.id = id;
        this.color = color;
        this.active = false;
        this.pos = new Vec2(0, 0);
        this.normal = new Vec2(0, 0);
        this.width = CONFIG.PORTAL_WIDTH;
    }

    place(pos, normal) {
        this.active = true;
        this.pos = pos;
        this.normal = normal;
    }
    
    getAngle() {
        return Math.atan2(this.normal.y, this.normal.x);
    }
}

class Player {
    constructor(x, y) {
        this.pos = new Vec2(x, y);
        this.vel = new Vec2(0, 0);
        this.size = CONFIG.PLAYER_SIZE;
        this.grounded = false;
        this.portalCooldown = 0;
        this.controlLockTimer = 0; 
    }

    getCenter() {
        return new Vec2(this.pos.x + this.size / 2, this.pos.y + this.size / 2);
    }
    
    getGhostPos(portals) {
        if (!portals || !portals[0].active || !portals[1].active) return null;
        
        const center = this.getCenter();
        let nearPortal = null;
        let destPortal = null;
        let dist = 0;

        const detectionRadius = 450; 

        const dist0 = center.sub(portals[0].pos).mag();
        const dist1 = center.sub(portals[1].pos).mag();

        if (dist0 < detectionRadius) {
            nearPortal = portals[0];
            destPortal = portals[1];
            dist = dist0;
        } else if (dist1 < detectionRadius) {
            nearPortal = portals[1];
            destPortal = portals[0];
            dist = dist1;
        }

        if (nearPortal && destPortal) {
            const tangentIn = new Vec2(-nearPortal.normal.y, nearPortal.normal.x);
            const tangentOut = new Vec2(-destPortal.normal.y, destPortal.normal.x);
            let offsetV = center.sub(nearPortal.pos);
            
            const offsetAlongNormal = offsetV.dot(nearPortal.normal);
            const offsetAlongTangent = offsetV.dot(tangentIn);
            
            const newOffsetNormal = destPortal.normal.mult(-offsetAlongNormal);
            const newOffsetTangent = tangentOut.mult(offsetAlongTangent);
            
            let newOffset = newOffsetNormal.add(newOffsetTangent);
            
            let strength = Math.max(0, 1 - (dist / detectionRadius));
            strength = strength * strength; 

            return { 
                pos: destPortal.pos.add(newOffset), 
                strength: strength 
            };
        }
        return null;
    }

    update(input, walls, portals) {
        const velBeforeWalking = new Vec2(this.vel.x, this.vel.y);
        
        if (this.controlLockTimer > 0) {
            this.controlLockTimer--;
        }

        let wishDir = 0;
        if (this.controlLockTimer <= 0) {
        if (input.keys['a']) wishDir -= 1;
        if (input.keys['d']) wishDir += 1;
        }

        const absVelX = Math.abs(this.vel.x);
        const velRatio = Math.min(1.0, absVelX / CONFIG.MAX_SPEED); 
        
        let groundRetention;
        if (this.grounded) {
            groundRetention = CONFIG.LOW_SPEED_GROUND_RETENTION + 
                           (CONFIG.HIGH_SPEED_GROUND_RETENTION - CONFIG.LOW_SPEED_GROUND_RETENTION) * velRatio;
        }
        
        if (this.grounded) {
            this.vel.x *= groundRetention;
        }
        
        this.vel.y += CONFIG.GRAVITY;

        if (wishDir !== 0) {
            const baseRetention = CONFIG.LOW_SPEED_GROUND_RETENTION;
            const groundAccel = CONFIG.MOVE_SPEED * (1 - baseRetention);
            
            let airAccel;
            if (!this.grounded) {
                airAccel = CONFIG.MAX_AIR_ACCEL - 
                          (CONFIG.MAX_AIR_ACCEL - CONFIG.MIN_AIR_ACCEL) * velRatio;
            }
            
            const currentAccel = this.grounded ? groundAccel : airAccel;
            const maxMove = CONFIG.MOVE_SPEED;
            let currentSpeed = this.vel.x * wishDir;
            let addSpeed = maxMove - currentSpeed;
            if (addSpeed > 0) {
                let accelMagnitude = Math.min(currentAccel, addSpeed);
                this.vel.x += accelMagnitude * wishDir;
            }
        }
        
        if (input.keys['w'] && this.grounded) {
            this.vel.y = -CONFIG.JUMP_FORCE;
            this.grounded = false;
        }
        
        this.vel.x = Math.max(-CONFIG.MAX_SPEED, Math.min(CONFIG.MAX_SPEED, this.vel.x));
        this.vel.y = Math.max(-CONFIG.MAX_SPEED, Math.min(CONFIG.MAX_SPEED, this.vel.y));

        if (this.portalCooldown > 0) this.portalCooldown--;
        this.grounded = false;

        const dt = 1 / CONFIG.SUBSTEPS;
        for (let i = 0; i < CONFIG.SUBSTEPS; i++) {
            this.pos.x += this.vel.x * dt;
            this.pos.y += this.vel.y * dt;
            this.handlePortals(portals);
            this.handleCollisions(walls, portals);
        }
    }

    handleCollisions(walls, portals) {
        for (let wall of walls) {
            let ignoreWall = false;
            if (portals) {
                for (let p of portals) {
                    if (!p.active) continue;
                    
                    const center = this.getCenter();
                    const rel = center.sub(p.pos);
                    const tangent = new Vec2(-p.normal.y, p.normal.x);
                    const distTangent = rel.dot(tangent);
                    
                    if (Math.abs(distTangent) < p.width / 2) {
                         if (rel.mag() < this.size * 2) {
                            if (p.pos.x >= wall.x - 1 && p.pos.x <= wall.x + wall.w + 1 &&
                                p.pos.y >= wall.y - 1 && p.pos.y <= wall.y + wall.h + 1) {
                                ignoreWall = true;
                                break;
                            }
                         }
                    }
                }
            }

            if (ignoreWall) continue;

            if (this.pos.x < wall.x + wall.w &&
                this.pos.x + this.size > wall.x &&
                this.pos.y < wall.y + wall.h &&
                this.pos.y + this.size > wall.y) {

                let overlapX1 = (wall.x + wall.w) - this.pos.x;
                let overlapX2 = (this.pos.x + this.size) - wall.x;
                let overlapY1 = (wall.y + wall.h) - this.pos.y;
                let overlapY2 = (this.pos.y + this.size) - wall.y;
                let minOverlap = Math.min(overlapX1, overlapX2, overlapY1, overlapY2);

                if (minOverlap === overlapY1) {
                    this.pos.y = wall.y + wall.h;
                    this.vel.y = 0;
                } else if (minOverlap === overlapY2) {
                    this.pos.y = wall.y - this.size;
                    this.vel.y = 0;
                    this.grounded = true;
                } else if (minOverlap === overlapX1) {
                    this.pos.x = wall.x + wall.w;
                    this.vel.x = 0;
                } else if (minOverlap === overlapX2) {
                    this.pos.x = wall.x - this.size;
                    this.vel.x = 0;
                }
            }
        }
    }

    handlePortals(portals) {
        if (this.portalCooldown > 0) return;
        const p1 = portals[0];
        const p2 = portals[1];
        if (!p1.active || !p2.active) return;
        
        this.applyPortalSuction(p1);
        this.applyPortalSuction(p2);
        
        this.checkPortalIntersection(p1, p2);
        this.checkPortalIntersection(p2, p1);
    }

    applyPortalSuction(portal) {
        const center = this.getCenter();
        const speed = this.vel.mag();

        const MIN_SPEED = 5;        
        const SUCTION_RANGE = 150;  

        if (speed < MIN_SPEED) return;

        const predictTime = CONFIG.PORTAL_SUCTION_PREDICT_TIME;
        const predictedPos = center.add(this.vel.mult(predictTime * 60)); 
        const predictedDist = predictedPos.sub(portal.pos).mag();
        
        if (predictedDist >= SUCTION_RANGE) return;
        
        const toPortal = center.sub(portal.pos);
        const distNormal = toPortal.dot(portal.normal);
        
        if (distNormal >= 0) return; 
        
        const velAlongNormal = this.vel.dot(portal.normal);
        
        const MIN_ALIGNMENT = 0.3; 
        const alignmentRatio = -velAlongNormal / speed; 
        
        if (alignmentRatio > MIN_ALIGNMENT) {
            const tangent = new Vec2(-portal.normal.y, portal.normal.x);
            const offsetTangent = predictedPos.sub(portal.pos).dot(tangent);
            
            const correctionDir = tangent.mult(-Math.sign(offsetTangent));
            
            const proximityFactor = (1 - (predictedDist / SUCTION_RANGE)) ** 2; 
            const alignmentFactor = Math.min(1.0, alignmentRatio / 0.7); 
            
            const speedFactor = speed * CONFIG.PORTAL_SUCTION_SPEED_SCALE;
            
            const suctionForce = CONFIG.PORTAL_SUCTION * proximityFactor * alignmentFactor * speedFactor;
            
            this.vel = this.vel.add(correctionDir.mult(suctionForce));
        }
    }

    checkPortalIntersection(inPortal, outPortal) {
        const playerCenter = this.getCenter();
        const toPlayer = playerCenter.sub(inPortal.pos);
        const tangent = new Vec2(-inPortal.normal.y, inPortal.normal.x); 
        const distNormal = toPlayer.dot(inPortal.normal);
        const distTangent = toPlayer.dot(tangent);

        if (Math.abs(distTangent) < inPortal.width / 2) {
            const prevPos = this.pos.sub(this.vel.mult(1/CONFIG.SUBSTEPS));
            const prevCenter = new Vec2(prevPos.x + this.size/2, prevPos.y + this.size/2);
            const prevDistNormal = prevCenter.sub(inPortal.pos).dot(inPortal.normal);

            if (prevDistNormal > 0 && distNormal <= 0) {
                this.teleport(inPortal, outPortal);
            }
        }
    }

    teleport(inPortal, outPortal) {
        const tangentIn = new Vec2(-inPortal.normal.y, inPortal.normal.x);
        const tangentOut = new Vec2(-outPortal.normal.y, outPortal.normal.x);
        
        const velAlongNormal = this.vel.dot(inPortal.normal);
        const velAlongTangent = this.vel.dot(tangentIn);
        
        const newVelNormal = outPortal.normal.mult(-velAlongNormal);
        
        const redirectFactor = CONFIG.PORTAL_REDIRECT;
        const newVelTangent = tangentOut.mult(velAlongTangent * (1.0 - redirectFactor));
        
        let exitVel = newVelNormal.add(newVelTangent);
        
        this.vel = exitVel;

        let playerCenter = this.getCenter();
        let offsetV = playerCenter.sub(inPortal.pos);
        
        offsetV = offsetV.mult(0.2);
        
        const offsetAlongNormal = offsetV.dot(inPortal.normal);
        const offsetAlongTangent = offsetV.dot(tangentIn);
        const newOffsetNormal = outPortal.normal.mult(-offsetAlongNormal);
        const newOffsetTangent = tangentOut.mult(offsetAlongTangent);
        let newOffset = newOffsetNormal.add(newOffsetTangent);

        const currentSpeedSq = this.vel.mag() ** 2;
        const energyCorrection = 0; 
        let newSpeedSq = currentSpeedSq + energyCorrection;
        if (newSpeedSq < 0) newSpeedSq = 0;
        const newSpeed = Math.sqrt(newSpeedSq);
        if (this.vel.mag() > 0) {
             this.vel = this.vel.normalize().mult(newSpeed);
        }
        
        const minExitSpeed = 3; 
        if (this.vel.mag() < minExitSpeed) {
            this.vel = outPortal.normal.mult(minExitSpeed);
        }
        
        let newCenter = outPortal.pos.add(newOffset);
        
        if (!isFinite(newCenter.x) || !isFinite(newCenter.y)) {
            return;
        }
        
        this.pos.x = newCenter.x - this.size/2;
        this.pos.y = newCenter.y - this.size/2;
        this.portalCooldown = 2;
        
        const currentSpeed = this.vel.mag();
        const speedFactor = Math.max(0, 1.0 - (currentSpeed / CONFIG.CONTROL_LOCK_SPEED_THRESHOLD));
        const lockTime = CONFIG.MAX_CONTROL_LOCK_TIME * speedFactor;
        
        this.controlLockTimer = Math.floor(lockTime * 60); 
    }

    draw(ctx, portals) {
        this.drawBody(ctx, this.pos.x, this.pos.y);

        const ghostData = this.getGhostPos(portals);
        if (ghostData) {
            ctx.save();
            let visOpacity = Math.max(0, (ghostData.strength - 0.7) * 3.33);
            if (visOpacity > 0) {
                ctx.globalAlpha = 0.6 * visOpacity;
                this.drawBody(ctx, ghostData.pos.x - this.size/2, ghostData.pos.y - this.size/2);
            }
            ctx.restore();
        }
    }

    drawBody(ctx, x, y) {
        ctx.fillStyle = '#fff';
        ctx.fillRect(x, y, this.size, this.size);
        ctx.fillStyle = '#000';
        let lookDir = this.vel.mag() > 1 ? this.vel.normalize() : new Vec2(1, 0);
        ctx.fillRect(x + this.size/2 + lookDir.x * 6 - 2, y + this.size/2 + lookDir.y * 6 - 2, 4, 4);
    }
}

/**
 * MAIN GAME LOOP & STATE
 */
const canvas = document.getElementById('gameCanvas');
const container = document.getElementById('game-container');
const ctx = canvas.getContext('2d');

let width, height;
const input = {
    keys: {},
    screenMouse: new Vec2(0, 0)
};

let player, camera;
let walls = [];
let portals = [];
let particles = [];
let bullets = [];
let isPaused = false;
let inMenu = true; // Start in menu

class Bullet {
    constructor(startPos, dir, color, portalId) {
        this.pos = startPos;
        this.vel = dir.mult(40); // High speed
        this.color = color;
        this.portalId = portalId;
        this.life = 100; // Failsafe
        this.trail = [];
        this.trailLength = 5;
    }

    update(walls) {
        this.life--;
        if (this.life <= 0) return false;

        // Update trail
        this.trail.unshift(new Vec2(this.pos.x, this.pos.y));
        if (this.trail.length > this.trailLength) {
            this.trail.pop();
        }

        // Move and check collision
        const nextPos = this.pos.add(this.vel);
        const hit = castRay(this.pos, this.vel.normalize(), walls);
        
        // Check if we hit something in this frame
        if (hit) {
            const distToHit = Math.sqrt(Math.pow(hit.pos.x - this.pos.x, 2) + Math.pow(hit.pos.y - this.pos.y, 2));
            const distToNext = this.vel.mag();
            
            if (distToHit <= distToNext) {
                // Hit wall!
                createPortal(this.portalId, hit.pos, hit.normal);
                soundManager.playLand(); // Play land sound
                
                // Spawn particles
                for (let i = 0; i < 10; i++) {
                    particles.push({
                        pos: hit.pos.add(hit.normal.mult(2)),
                        vel: new Vec2((Math.random() - 0.5) * 5 + hit.normal.x * 5, (Math.random() - 0.5) * 5 + hit.normal.y * 5),
                        life: 30, // Lasts 0.5 seconds
                        color: this.color
                    });
                }
                return false; // Destroy bullet
            }
        }

        this.pos = nextPos;
        return true;
    }

    draw(ctx) {
        // Draw trail
        if (this.trail.length > 1) {
            ctx.beginPath();
            ctx.moveTo(this.trail[0].x, this.trail[0].y);
            for (let i = 1; i < this.trail.length; i++) {
                ctx.lineTo(this.trail[i].x, this.trail[i].y);
            }
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.globalAlpha = 0.6;
            ctx.stroke();
            ctx.globalAlpha = 1.0;
        }

        // Draw head
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(this.pos.x, this.pos.y, 4, 0, Math.PI * 2);
        ctx.fill();
    }
}

function createPortal(id, pos, normal) {
    portals[id].active = true;
    portals[id].pos = pos;
    portals[id].normal = normal;
    portals[id].width = CONFIG.PORTAL_WIDTH; 
}

function togglePause() {
    if (inMenu) return; // Can't pause in main menu
    isPaused = !isPaused;
    const ui = document.getElementById('ui');
    if (isPaused) {
        ui.classList.add('paused');
    } else {
        ui.classList.remove('paused');
    }
}

function startGame() {
    inMenu = false;
    document.getElementById('main-menu').classList.add('hidden');
    soundManager.init(); // Start audio on user gesture
    resetLevel();
}

function resize() {
    const aspect = 16 / 9;
    let w = window.innerWidth;
    let h = window.innerHeight;
    
    if (w / h > aspect) {
        w = h * aspect;
    } else {
        h = w / aspect;
    }
    
    container.style.width = w + 'px';
    container.style.height = h + 'px';
    canvas.width = w;
    canvas.height = h;
}

function resetLevel() {
    player = new Player(300, WORLD_H - 100);
    camera = new Camera(player.pos.x, player.pos.y); 
    portals = [new Portal(0, '#00A2FF'), new Portal(1, '#FF9900')];
    bullets = []; // Clear bullets on reset
    particles = []; // Clear particles
    
    walls = [
        {x: 0, y: 0, w: WORLD_W, h: 40}, 
        {x: 0, y: WORLD_H-40, w: WORLD_W, h: 40}, 
        {x: 0, y: 0, w: 40, h: WORLD_H}, 
        {x: WORLD_W-40, y: 0, w: 40, h: WORLD_H}, 
        
        {x: 200, y: WORLD_H - 250, w: 200, h: 20},
        {x: 700, y: WORLD_H - 500, w: 40, h: 500},
        {x: 800, y: 300, w: 400, h: 40},
        {x: 150, y: 400, w: 150, h: 20},
        
        {x: WORLD_W - 400, y: WORLD_H - 150, w: 60, h: 110},
        {x: WORLD_W - 340, y: WORLD_H - 250, w: 60, h: 210},
        {x: WORLD_W - 280, y: WORLD_H - 350, w: 60, h: 310},
    ];
}

function init() {
    resize();
    window.addEventListener('resize', resize);
    
    window.addEventListener('keydown', e => {
        const key = e.key.toLowerCase();
        if (key === 'escape') {
            e.preventDefault();
            e.stopPropagation();
            togglePause();
            return;
        }
        
        if (!isPaused && !inMenu) {
            if (key === 'q') shootPortal(0);
            if (key === 'e') shootPortal(1);
        }
        
        input.keys[key] = true;
    });
    window.addEventListener('keyup', e => input.keys[e.key.toLowerCase()] = false);
    window.addEventListener('blur', () => {
        input.keys = {};
    });

    window.addEventListener('mousemove', e => {
        const rect = canvas.getBoundingClientRect();
        let mx = e.clientX - rect.left;
        let my = e.clientY - rect.top;
        // Clamp to canvas dimensions to avoid black bar drift
        input.screenMouse.x = Math.max(0, Math.min(canvas.width, mx));
        input.screenMouse.y = Math.max(0, Math.min(canvas.height, my));
    });
    
    window.addEventListener('contextmenu', e => e.preventDefault());

    document.getElementById('resumeBtn').addEventListener('click', () => {
        if (isPaused) togglePause();
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
        resetLevel();
        if (isPaused) togglePause(); 
    });

    // Main Menu Start Button
    document.getElementById('startBtn').addEventListener('click', startGame);

    resetLevel();
    requestAnimationFrame(loop);
}

function isPointInWall(point, walls) {
    for (let wall of walls) {
        if (point.x >= wall.x && point.x <= wall.x + wall.w &&
            point.y >= wall.y && point.y <= wall.y + wall.h) {
            return true;
        }
    }
    return false;
}

function shootPortal(id) {
    if (inMenu) return;
    
    const worldMouse = camera.screenToWorld(input.screenMouse, canvas);
    const playerCenter = new Vec2(player.pos.x + player.size/2, player.pos.y + player.size/2);
    
    const dir = worldMouse.sub(playerCenter).normalize();
    let anchorPoint = playerCenter.add(dir.mult(CONFIG.PORTAL_ANCHOR_DISTANCE));
    
    if (isPointInWall(anchorPoint, walls)) {
        anchorPoint = playerCenter;
    }
    
    bullets.push(new Bullet(anchorPoint, dir, portals[id].color, id));
    soundManager.playShoot(); // Play shoot sound
}

function update() {
    if (isPaused || inMenu) return;
    
    player.update(input, walls, portals);
    const ghostData = player.getGhostPos(portals);
    camera.follow(player.getCenter(), input.screenMouse, canvas, ghostData, portals, input.keys[' ']);
    
    // Update bullets
    for (let i = bullets.length - 1; i >= 0; i--) {
        if (!bullets[i].update(walls)) {
            bullets.splice(i, 1);
        }
    }
    
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.pos = p.pos.add(p.vel);
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
    }
}

function drawPortalPreview(ctx, pos, normal) {
    ctx.save();
    ctx.translate(pos.x, pos.y);
    const angle = Math.atan2(normal.y, normal.x);
    ctx.rotate(angle);
    
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
    ctx.lineWidth = 2;
    ctx.strokeRect(0, -CONFIG.PORTAL_WIDTH/2, 3, CONFIG.PORTAL_WIDTH);
    
    ctx.restore();
}

function draw() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Even if in menu, we can draw the game background for style, 
    // but maybe just keep it black or draw it static.
    // Let's draw it active but paused-looking if in menu
    
    ctx.save();
    
    camera.apply(ctx, canvas);

    ctx.fillStyle = '#222';
    ctx.fillRect(0, 0, WORLD_W, WORLD_H);
    
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let x=0; x<=WORLD_W; x+=100) { ctx.moveTo(x,0); ctx.lineTo(x, WORLD_H); }
    for(let y=0; y<=WORLD_H; y+=100) { ctx.moveTo(0,y); ctx.lineTo(WORLD_W, y); }
    ctx.stroke();
    
    ctx.fillStyle = '#444';
    for (let w of walls) {
        ctx.fillRect(w.x, w.y, w.w, w.h);
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 2;
        ctx.strokeRect(w.x, w.y, w.w, w.h);
    }
    
    for (let p of portals) {
        if (p.active) {
            ctx.save();
            ctx.translate(p.pos.x, p.pos.y);
            ctx.rotate(p.getAngle());
            ctx.shadowBlur = 20;
            ctx.shadowColor = p.color;
            ctx.fillStyle = p.color;
            ctx.fillRect(0, -p.width/2, 4, p.width); 
            ctx.fillStyle = '#000';
            ctx.fillRect(-2, -p.width/2 + 2, 2, p.width - 4);
            ctx.restore();
        }
    }
    
    // Draw bullets
    for (let bullet of bullets) {
        bullet.draw(ctx);
    }
    
    const worldMouse = camera.screenToWorld(input.screenMouse, canvas);
    const playerCenter = new Vec2(player.pos.x + player.size/2, player.pos.y + player.size/2);
    
    // Calculate direction from player to mouse
    const dirToMouse = worldMouse.sub(playerCenter).normalize();
    
    // Calculate anchor point offset from player center in direction of mouse
    let anchorPoint = playerCenter.add(dirToMouse.mult(CONFIG.PORTAL_ANCHOR_DISTANCE));
    
    // If anchor point is inside a wall, use player center instead
    if (isPointInWall(anchorPoint, walls)) {
        anchorPoint = playerCenter;
    }
    
    // Cast ray from anchor point to mouse direction to find first wall hit
    const rayHit = castRay(anchorPoint, dirToMouse, walls);
    
    // Use hit point if found, otherwise extend far in that direction
    const lineEnd = rayHit ? rayHit.pos : anchorPoint.add(dirToMouse.mult(5000));

    ctx.beginPath();
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.lineWidth = 2;
    ctx.moveTo(anchorPoint.x, anchorPoint.y);
    ctx.lineTo(lineEnd.x, lineEnd.y);
    ctx.stroke();
    
    if (!inMenu) {
        ctx.beginPath();
        ctx.arc(worldMouse.x, worldMouse.y, 5, 0, Math.PI*2);
        ctx.strokeStyle = '#fff';
        ctx.stroke();
    }
    
    for (let p of particles) {
        ctx.fillStyle = p.color;
        ctx.fillRect(p.pos.x, p.pos.y, 3, 3);
    }
    
    player.draw(ctx, portals);

    ctx.restore();
    
    if (!inMenu) {
        drawPortalEdgeIndicators(ctx, canvas, camera, portals);
        drawPlayerEdgeIndicator(ctx, canvas, camera, player);
    }
}

function drawPortalEdgeIndicators(ctx, canvas, camera, portals) {
    const viewHalfW = (canvas.width / camera.zoom) / 2;
    const viewHalfH = (canvas.height / camera.zoom) / 2;
    
    const edgeMargin = 20; 
    const indicatorSize = 30;
    
    for (let portal of portals) {
        if (!portal.active) continue;
        
        const portalX = portal.pos.x;
        const portalY = portal.pos.y;
        
        const screenCenterX = canvas.width / 2;
        const screenCenterY = canvas.height / 2;
        const portalScreenX = screenCenterX + (portalX - camera.pos.x) * camera.zoom;
        const portalScreenY = screenCenterY + (portalY - camera.pos.y) * camera.zoom;
        
        const isOutside = portalScreenX < 0 || portalScreenX > canvas.width || 
                         portalScreenY < 0 || portalScreenY > canvas.height;
        
        if (!isOutside) continue; 
        
        const minX = edgeMargin;
        const maxX = canvas.width - edgeMargin;
        const minY = edgeMargin;
        const maxY = canvas.height - edgeMargin;
        
        let screenX = Math.max(minX, Math.min(maxX, portalScreenX));
        let screenY = Math.max(minY, Math.min(maxY, portalScreenY));
        
        let angle = Math.atan2(portalScreenY - screenY, portalScreenX - screenX);
        
        ctx.save();
        ctx.translate(screenX, screenY);
        ctx.rotate(angle);
        
        const color = portal.color;
        const r = parseInt(color.slice(1, 3), 16);
        const g = parseInt(color.slice(3, 5), 16);
        const b = parseInt(color.slice(5, 7), 16);
        
        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.4)`;
        ctx.strokeStyle = portal.color; 
        ctx.lineWidth = 3; 
        
        ctx.beginPath();
        ctx.moveTo(indicatorSize, 0);
        ctx.lineTo(-indicatorSize/2, -indicatorSize/2);
        ctx.lineTo(-indicatorSize/2, indicatorSize/2);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        ctx.shadowBlur = 15;
        ctx.shadowColor = portal.color;
        ctx.fill();
        ctx.shadowBlur = 0;
        
        ctx.restore();
    }
}

function drawPlayerEdgeIndicator(ctx, canvas, camera, player) {
    const viewHalfW = (canvas.width / camera.zoom) / 2;
    const viewHalfH = (canvas.height / camera.zoom) / 2;
    
    const playerCenter = player.getCenter();
    const playerX = playerCenter.x;
    const playerY = playerCenter.y;
    
    const screenCenterX = canvas.width / 2;
    const screenCenterY = canvas.height / 2;
    const playerScreenX = screenCenterX + (playerX - camera.pos.x) * camera.zoom;
    const playerScreenY = screenCenterY + (playerY - camera.pos.y) * camera.zoom;
    
    const isOutside = playerScreenX < 0 || playerScreenX > canvas.width || 
                     playerScreenY < 0 || playerScreenY > canvas.height;
    
    if (!isOutside) return; 
    
    const edgeMargin = 20; 
    const indicatorSize = 35; 
    
    const minX = edgeMargin;
    const maxX = canvas.width - edgeMargin;
    const minY = edgeMargin;
    const maxY = canvas.height - edgeMargin;
    
    let screenX = Math.max(minX, Math.min(maxX, playerScreenX));
    let screenY = Math.max(minY, Math.min(maxY, playerScreenY));
    
    let angle = Math.atan2(playerScreenY - screenY, playerScreenX - screenX);
    
    ctx.save();
    ctx.translate(screenX, screenY);
    ctx.rotate(angle);
    
    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)'; 
    ctx.strokeStyle = '#fff'; 
    ctx.lineWidth = 3; 
    
    ctx.beginPath();
    ctx.moveTo(indicatorSize, 0);
    ctx.lineTo(-indicatorSize/2, -indicatorSize/2);
    ctx.lineTo(-indicatorSize/2, indicatorSize/2);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    ctx.shadowBlur = 20;
    ctx.shadowColor = '#fff';
    ctx.fill();
    ctx.shadowBlur = 0;
    
    ctx.restore();
}

let lastTime = 0;
let accumulator = 0;
const FIXED_STEP = 1 / 60; 

function loop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    
    let deltaTime = (timestamp - lastTime) / 1000;
    lastTime = timestamp;
    
    if (deltaTime > 0.1) deltaTime = 0.1;
    
    accumulator += deltaTime;
    
    while (accumulator >= FIXED_STEP) {
        update();
        accumulator -= FIXED_STEP;
    }
    
    draw();
    requestAnimationFrame(loop);
}

init();

</script>
</body>
</html>
